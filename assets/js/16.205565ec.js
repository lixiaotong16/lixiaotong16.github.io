(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{359:function(t,e,s){t.exports=s.p+"assets/img/12.bc85efdd.png"},474:function(t,e,s){"use strict";s.r(e);var a=s(35),r=Object(a.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"_04-浏览器的页面循环系统"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_04-浏览器的页面循环系统"}},[t._v("#")]),t._v(" 04：浏览器的页面循环系统")]),t._v(" "),a("h2",{attrs:{id:"消息队列和事件循环-页面是怎么-活-起来的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#消息队列和事件循环-页面是怎么-活-起来的"}},[t._v("#")]),t._v(" 消息队列和事件循环：页面是怎么“活”起来的？")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("消息队列和事件循环机制\n在线程运行过程中，通过事件循环机制可以接收并执行新的任务，通过消息队列，可以处理其他线程发来的任务。\n"),a("img",{attrs:{src:s(359),alt:"队列+循环"}}),t._v("\n对于跨进程任务，渲染进程中专门有一个 IO 线程用于接收其他进程传过来的消息，会将这些消息组装成任务。")])]),t._v(" "),a("li",[a("p",[t._v("微任务\n消息队列机制并不是太灵活，为了适应效率和实时性，引入了微任务。")])])]),t._v(" "),a("h2",{attrs:{id:"webapi-settimeout-是如何实现的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webapi-settimeout-是如何实现的"}},[t._v("#")]),t._v(" WebAPI：setTimeout 是如何实现的？")])])}),[],!1,null,null,null);e.default=r.exports}}]);