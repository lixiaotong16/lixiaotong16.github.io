(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{359:function(s,t,a){s.exports=a.p+"assets/img/12.bc85efdd.png"},426:function(s,t,a){s.exports=a.p+"assets/img/10.ea55c4d7.png"},427:function(s,t,a){s.exports=a.p+"assets/img/11.5387a511.png"},472:function(s,t,a){"use strict";a.r(t);var n=a(35),r=Object(n.a)({},(function(){var s=this,t=s.$createElement,n=s._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("h1",{attrs:{id:"_03-v8-工作原理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_03-v8-工作原理"}},[s._v("#")]),s._v(" 03：V8 工作原理")]),s._v(" "),n("h2",{attrs:{id:"栈空间和堆空间-数据时如何存储的"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#栈空间和堆空间-数据时如何存储的"}},[s._v("#")]),s._v(" 栈空间和堆空间：数据时如何存储的")]),s._v(" "),n("ol",[n("li",[n("p",[s._v("js 语言类型和数据类型\n  js 是一种弱类型（支持隐式类型转换）、动态（不需要在使用时就明确数据类型，而是在运行过程中检查数据类型）语言\n  js 数据类型一共有 8 种：\n"),n("img",{attrs:{src:a(426),alt:"8种数据类型"}})]),s._v(" "),n("blockquote",[n("p",[s._v("使用 typeof 检测 null 类型时，返回的是 Object，这是一个老的 bug")])]),s._v(" "),n("p",[s._v("  前 7 种类型为原始类型，最后一个对象类型为引用类型，两种类型的存储位置是不同的")])]),s._v(" "),n("li",[n("p",[s._v("内存空间\n分为代码空间、栈空间、堆空间\n(1) 栈空间即为之前所说的调用栈，原始类型的数据都直接保存在栈中；引用类型的值存放在堆中，栈中只保存其引用地址。因为栈需要频繁切换上下文，空间不会设的很大，只能存放一些原始类型的小数据。例子如下：")]),s._v(" "),n("div",{staticClass:"language-js line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("function")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[s._v("foo")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("var")]),s._v(" a "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[s._v('"极客时间"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("var")]),s._v(" b "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" a"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("var")]),s._v(" c "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token literal-property property"}},[s._v("name")]),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[s._v('"极客时间"')]),s._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("var")]),s._v(" d "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" c"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token function"}},[s._v("foo")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br")])]),n("p",[n("img",{attrs:{src:a(427),alt:""}})])]),s._v(" "),n("li",[n("p",[s._v("再看闭包\n闭包也是在堆中存放的一个对象，因此即使外部函数的上下文被销毁了，内部函数对闭包的引用还在。")])])]),s._v(" "),n("h2",{attrs:{id:"垃圾回收-垃圾数据是如何自动回收的"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收-垃圾数据是如何自动回收的"}},[s._v("#")]),s._v(" 垃圾回收：垃圾数据是如何自动回收的")]),s._v(" "),n("p",[s._v("js 中产生的垃圾是由垃圾回收器释放的")]),s._v(" "),n("ol",[n("li",[n("p",[s._v("调用栈中的数据如何回收\n当函数调用结束后，js 引擎会通过向下移动 EPS（一个记录当前执行状态的指针）来销毁该函数的执行上下文。无效的上下文会被新的上下文给覆盖。")])]),s._v(" "),n("li",[n("p",[s._v("堆中的数据如何回收\n通过 js 中的垃圾回收器。\nV8 将堆分为新生代和老生代，新生代存放生存时间短的对象，老生代存放生存时间久的对象。新生代容量小，老生代容量大。\nV8 使用两个不同的垃圾回收器，副垃圾回收器回收新生代垃圾，主垃圾回收器回收老生代垃圾。但是两者的回收思路是共同的：先标记空间内的活动对象和非活动对象，然后回收非活动对象所占据的内存，最后可能会整理下内存碎片。")]),s._v(" "),n("ul",[n("li",[s._v("副垃圾回收器——回收新生代垃圾：Scavenge 算法\n将新生区分为对象区域和空闲区域，新加入的对象都会被放到对象区域，每当快满了的时候，进行一次垃圾清理。\n首先对对象区域内的垃圾做标记，然后把剩余存活的对象复制到空闲区域，并将两个区域进行角色翻转。\n由于新生区空间不大，存活的对象很容易就被填满了，因此如果经过两次垃圾回收还存活着，会被移动到老生区，称为对象晋升策略。")]),s._v(" "),n("li",[s._v("主垃圾回收器——老生代垃圾：\n"),n("ul",[n("li",[s._v("标记-清除方法：首先通过递归遍历的方式标记出活动对象和垃圾对象，然后清除垃圾对象。")]),s._v(" "),n("li",[s._v("标记-整理法：由于会产生内存碎片，因此还有标记-整理方法，即不清除垃圾对象，而是将活动对象移到一侧，清除其余的内存。")]),s._v(" "),n("li",[s._v("增量标记法：由于 js 是运行在主线程之上的，因此一次垃圾回收会阻塞主线程的 js 脚本（尤其是老生代垃圾回收，因为空间很大），出现全停顿。因此 V8 将标记过程分为一个个子标记过程，让标记过程和 js 应用逻辑交替进行，直至标记完成。\n"),n("img",{attrs:{src:a(359),alt:"增量标记"}})])])])])]),s._v(" "),n("li",[n("p",[s._v("如何判断和避免内存泄漏\n(1)判断：感官上长时间的卡顿或者借助 Performance 来观察。\n(2)确定不使用的临时变量设置为 null，以及减少闭包的使用。")])])]),s._v(" "),n("h2",{attrs:{id:"编译器和解释器-v8-是如何执行一段-javascript-代码的"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#编译器和解释器-v8-是如何执行一段-javascript-代码的"}},[s._v("#")]),s._v(" 编译器和解释器：V8 是如何执行一段 JavaScript 代码的")]),s._v(" "),n("ol",[n("li",[n("p",[s._v("编译器和解释器")])]),s._v(" "),n("li",[n("p",[s._v("V8 如何执行 js 代码\njs 是解释型语言，每次运行时都需要解释器对程序进行动态解释和执行。\n(1) 生成抽象语法树(AST)和执行上下文\n对于解释器或者编译器来说，他们可以理解的是 AST，因此需要将代码转变成 AST。生成 AST 需要经过两个阶段：")]),s._v(" "),n("ul",[n("li",[s._v("分词/词法分析：将源码拆解成一个个 token（语法上不能再分的最小单个字符或字符串）")]),s._v(" "),n("li",[s._v("解析/语法分析：将上一步的 token 根据语法规则转成 AST")])]),s._v(" "),n("p",[s._v("有了 AST 之后，V8 就会生成该段代码的执行上下文\n(2)生成字节码\n解释器会根据 AST 生成字节码，并解释执行字节码\n(3) 执行字节码\n如果是第一次执行的字节码，则解释器会逐条执行，在执行过程中，如果发现热点代码（一段代码被执行了多次），则编译器会将该段热点的字节码编译为更加高效的机器码，等到这段代码被再次执行时，只需要执行编译后的机器码即可，这样大大提升了代码的执行效率。\n字节码配合解释器和编译器的技术被称为即时编译（JIT）技术。")])]),s._v(" "),n("li",[n("p",[s._v("扩展：JS 的性能优化\n由于 V8 架构不断地优化，目前对 JS 的性能优化应该聚焦在单次脚本的执行时间和脚本的网络下载上，具体可以关注以下三点：\n(1)提高单次脚本的执行速度，避免长任务占据主线程；\n(2)避免大的内联脚本，因为在解析 HTML 过程中，解析和编译也会占用主线程；\n(3)减少 JS 文件的容量，这会影响下载速度")])])])])}),[],!1,null,null,null);t.default=r.exports}}]);