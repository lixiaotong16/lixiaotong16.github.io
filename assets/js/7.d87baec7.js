(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{423:function(t,s,a){t.exports=a.p+"assets/img/forward_proxy.257e7f5b.jpg"},424:function(t,s,a){t.exports=a.p+"assets/img/reverse_proxy.40945596.jpg"},425:function(t,s,a){t.exports=a.p+"assets/img/swimlane.ea39cbd5.png"},471:function(t,s,a){"use strict";a.r(s);var r=a(35),e=Object(r.a)({},(function(){var t=this,s=t.$createElement,r=t._self._c||s;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"开发中遇到的一些概念补充"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#开发中遇到的一些概念补充"}},[t._v("#")]),t._v(" 开发中遇到的一些概念补充")]),t._v(" "),r("h2",{attrs:{id:"代理服务器相关"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#代理服务器相关"}},[t._v("#")]),t._v(" 代理服务器相关")]),t._v(" "),r("p",[t._v("代理服务器分为转发代理（forward proxy）服务器和反向代理（reverse proxy）服务器")]),t._v(" "),r("h3",{attrs:{id:"转发代理服务器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#转发代理服务器"}},[t._v("#")]),t._v(" 转发代理服务器")]),t._v(" "),r("p",[r("img",{attrs:{src:a(423),alt:"转发代理服务器"}})]),t._v(" "),r("p",[t._v("转发代理服务器一般简称为代理服务器，处于客户端和原始服务器之间的中间服务器。\n客户端将请求发送到代理服务器，然后代理服务器从原始服务器中获取内容，并返回给客户端。\n客户端需要配置转发代理才可以，如在浏览器中配置代理服务器地址和端口号等等。\n应用场景：校园网用户通过代理访问外部网站，公司内网通过代理访问外部网站。")]),t._v(" "),r("h3",{attrs:{id:"反向代理服务器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#反向代理服务器"}},[t._v("#")]),t._v(" 反向代理服务器")]),t._v(" "),r("p",[r("img",{attrs:{src:a(424),alt:"反向代理服务器"}})]),t._v(" "),r("p",[t._v("对于客户端而言，反向代理服务器类似于原始服务器，客户端不需要任何配置。\n客户端向反向代理服务器发送请求，由反向代理服务器决定该请求具体发往哪个原始服务器。\n作用：")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("安全过滤：为了安全，不允许用户直接接触真实服务器，任何访问请求都要先到达反向代理服务器，反向代理服务器来进行验证、过滤等安全类操作，符合条件的请求才会被转发到真实服务器。例如最简单的场景：只有在 IP 白名单中的 IP 才能访问")])]),t._v(" "),r("li",[r("p",[t._v("内容缓存：当访问量越来越大时，网站服务器对每个请求都需要进行处理，压力巨大，根据局部访问性原理，这么多请求中必然有很多是重复的，这时反向代理服务器把一些常用的内容都缓存到自己身上，用户的请求先来到反向代理服务器，他看自己这有没有用户需要的内容，有就直接返回给用户，没有时才交给网站服务器来处理。")])]),t._v(" "),r("li",[r("p",[t._v("负载均衡：当访问量越来越大时，一个网站服务器扛不住了，需要在添加 N 个服务器，那么当用户请求过来后，思考一下这个请求应该交给谁，想好后就转发过去，这样就让 N 台服务器均衡的处理请求了。")])])]),t._v(" "),r("h2",{attrs:{id:"为什么要设置-host"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#为什么要设置-host"}},[t._v("#")]),t._v(" 为什么要设置 host")]),t._v(" "),r("p",[t._v("host 文件为优先级最高的本地映射表，当访问网址的时候，系统会先在 host 文件中找到 url 对应的 ip，如果有，就按照这个 ip 找到真正的服务器进行访问。\n因此修改 host 文件的目的就是劫持请求，在请求 dns 服务器解析 ip 前，提前把 url 和对应的服务器 ip 地址映射关系配置好。\nhost 文件用于本地 DNS 解析，并且优先于寻找网络上的 DNS 服务器。\n在 mac 中，她位于/etc/hosts\n文件每一行为一对映射关系，前面写 ip 地址，后面写主机名，中间用空格分隔。如：\n127.0.0.1 localhost")]),t._v(" "),r("h2",{attrs:{id:"前端需要了解的泳道知识"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#前端需要了解的泳道知识"}},[t._v("#")]),t._v(" 前端需要了解的泳道知识")]),t._v(" "),r("p",[r("img",{attrs:{src:a(425),alt:"泳道示意图"}}),t._v("\n一个环境内会有一条骨干链路(该环境的默认链路)和多条泳道\n泳道相当于提供了多条“请求的跑道”，理解泳道主要在于理解“流量跑到哪去了”:")]),t._v(" "),r("p",[t._v("(1) 泳道内如果没有部署被调用服务，流量会 fallback 到骨干")]),t._v(" "),r("p",[t._v("(2) 泳道内若存在被调用节点，那么流量是一定不会 fallback 的 (包括不可用的和禁用的)")]),t._v(" "),r("p",[t._v("(3) 骨干环境是一定不会调用到泳道内的")]),t._v(" "),r("p",[t._v("(4) 泳道之间是一定不会互相调用的")]),t._v(" "),r("p",[t._v("前端主要负责服务导流：\n方法 1：通过域名划分泳道，为每个泳道申请单独的域名，根据域名进行分流，如在实习的时候，在测试的地址前面加上包含泳道名-sl-的标识\n方法 2：通过 header 携带泳道信息，在请求头中添加"),r("code",[t._v("swimlane=xxx")]),t._v("标识请求的泳道，分流系统会根据该字段进行分流\n"),r("a",{attrs:{href:"https://blog.csdn.net/zz_jesse/article/details/112001048",target:"_blank",rel:"noopener noreferrer"}},[t._v("泳道参考链接"),r("OutboundLink")],1)]),t._v(" "),r("h2",{attrs:{id:"前端环境变量"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#前端环境变量"}},[t._v("#")]),t._v(" 前端环境变量")])])}),[],!1,null,null,null);s.default=e.exports}}]);