(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{457:function(e,t,r){"use strict";r.r(t);var n=r(35),a=Object(n.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"react-相关文章"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react-相关文章"}},[e._v("#")]),e._v(" react 相关文章")]),e._v(" "),r("ul",[r("li",[r("p",[r("a",{attrs:{href:"https://blog.csdn.net/sinat_17775997/article/details/123610645",target:"_blank",rel:"noopener noreferrer"}},[e._v("react 判断是否登录，路由进行重定向"),r("OutboundLink")],1)])]),e._v(" "),r("li",[r("p",[r("a",{attrs:{href:"https://blog.csdn.net/sinat_17775997/article/details/123211231",target:"_blank",rel:"noopener noreferrer"}},[e._v("react 缓存页面"),r("OutboundLink")],1)])]),e._v(" "),r("li",[r("p",[r("a",{attrs:{href:"https://blog.csdn.net/sinat_17775997/article/details/123114146",target:"_blank",rel:"noopener noreferrer"}},[e._v("React redux-persist 持久化数据存储"),r("OutboundLink")],1)]),e._v(" "),r("blockquote",[r("p",[e._v("当使用 redux 时，一刷新，redux 中的数据就会被清空。")])])]),e._v(" "),r("li",[r("p",[e._v("【推荐】"),r("a",{attrs:{href:"https://blog.csdn.net/sinat_17775997/article/details/122884968",target:"_blank",rel:"noopener noreferrer"}},[e._v("React Hooks 避免的错误"),r("OutboundLink")],1)])]),e._v(" "),r("li",[r("p",[r("a",{attrs:{href:"https://mp.weixin.qq.com/s/a8k6QzDJEwF8SKhyKYtwyg",target:"_blank",rel:"noopener noreferrer"}},[e._v("React 新文档：不要滥用 effect 哦"),r("OutboundLink")],1)]),e._v(" "),r("blockquote",[r("p",[e._v("总结：\n当我们编写组件时，应该尽量将组件编写为纯函数。\n对于组件中的副作用，首先应该明确：\n是「用户行为触发的」还是「视图渲染后主动触发的」？\n对于前者，将逻辑放在 Event handlers 中处理。\n对于后者，使用 useEffect 处理。\n这也是为什么 useEffect 所在章节在新文档中叫做 Escape Hatches —— 大部分情况下，你不会用到 useEffect，这只是其他情况都不适应时的逃生舱。")])])])])])}),[],!1,null,null,null);t.default=a.exports}}]);